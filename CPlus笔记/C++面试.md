# C++面试

### 基础语法

- C++的`for循环`中定义的变量的作用域只限定于循环体内部；

- `对象`的定义：一块能存储数据并具有某种类型的内存空间；

- 指针和引用的区别：

  ```
  1.指针是一个实体（需要分配内存），而引用仅是一个别名（不需要分配内存）；
  2.指针可以有多级，但是引用只有一级；
  3.指针可以为空，而引用不能为空且在定义时必须初始化；
  4.指针在初始化之后可以改变指向对象，而引用在初始化之后不能再改变指向对象（其本质是在C++内部实现是一个常量指针，即不能指向其它变量但是可以改变值大小）；
  5.指针和引用的自增和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行自增和自减；
  6.sizeof函数，指针是指针类型的大小，而引用是所引用变量的大小，如引用string变量，就是这个变量的大小。
  ```

- 左值引用和右值引用

  ```
  1）引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。
  int a=1; int &b=a;(正确) int &c=1;(错误)
  2）右值引用的标志是&&，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值。
  int a=1; int &&b=1;(正确) int &&b=a;(错误)
  3）std::move()，通过使用move函数可以使得右值引用可以使用左值赋值。
  int a=1; int &&b=std.move(a);(正确)
  4）右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值。
  5）作为函数返回值的&&是右值，直接声明出来的&&是左值。
  int &&b=std::move(a)和int a=5;//没有什么区别，等号左边就是左值，右边就是右值。
  参考：https://zhuanlan.zhihu.com/p/335994370
  ```
  
- `常量指针`(被指向的对象是常量)与`指针常量`(指针本身是常量)的区别

  ```
  常量指针：本质是一个指针，而用常量修饰它，指针是个常量，必须初始化，不能改变指向。
  	int a; int * const b = &a;
  指针常量：本质是一个常量，而用指针修饰它，能改变指向，不能改变所指对象的值。
  	const int *p;   int const *p;
  ------
  常量指针：可以指向其它变量，但是指向的值不能修改，必须被初始化；
  	e.g., int* const p; *p=5; (正确) p=&c; (错误)
  指针常量：不能再指向其它变量，但是指向的值可以修改；
  	e.g., const int* p; p=&a; (正确) *p=3; (错误)
  注：*象征着地址，const象征着内容；谁在前面谁就不允许改变。
  ```
  
- C++四种类型转换

  ```
  1）const_cast<type_id>(expression)：用于将常量转换成非常量，注意type_id一般是指针、引用、或者成员指针，为了指向它的地址
  	const int a = 10; 
  	const int &b = a; // 地址和a相同
  	int c = const_cast<int&>(b); // 地址与a不同
  2）static_cast<type_id>(expression)：用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
  主要有以下几种用法：
  ①用于基本数据类型，或者non_const到const（反过来必须用const_cast)
  ②把空指针转换为目标类型的指针, 不能在不同类型类型的指针之间互相转换
  ③将任何类型的表达式转换为void类型
  ④可以将子类类型的指针转换为父类类型的指针（这种转换的安全性需要开发人员来保证）
  ⑤不能用于整型和指针之间的互相转换
  ⑥也不能用于不同类型的引用之间的转换。
  3）dynamic_cast<type*>(expression)：用于动态类型转换。专门用于将多态基类的指针或引用，强制转换为派生类的指针或引用；
  ①用于执行安全的向下转型，可以将指向子类的父类指针转换为子类指针，但是要求父类有虚函数；
  ②能够检查转换的安全性。对于不安全的指针转换，转换结果返回NULL；
  ③如果是引用类型转换失败则抛出bad_cast的异常。
  ④只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。
  4）reinpreter_cast<type_id>(expression)：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；
  ①type_id可以是指针，引用，算术类型，函数指针或者成员指针；
  ②这个操作符可以在非相关的类型之间转换；
  ③操作只是简单的从一个指针到别的指针的值的二进制拷贝；
  ④在类型之间指向的内容不作任何类型的检查和转换。
  参考：https://www.jianshu.com/p/d85ee67d3776
  ```

- `string`类型的`sizeof`大小是固定的（因为字符串所占的字节是从堆中动态分配的），不同的实现库不一样，常见的是24。

- `野指针`和`悬空指针`的理解

  ```
  link：https://zhuanlan.zhihu.com/p/150926332
  1）野指针：未被初始化的指针；悬空指针：指针指向的内存空间已被释放；
  2）为了避免野指针，定义指针是时要及时初始化，或者置空nullptr；
  3）为了避免悬空指针，当指针指向的内存被释放后，及时置空该指针nullptr；或者应用C++提供的智能指针；
  4）造成野指针的三种原因：①指针未被初始化；②指针指向的地址空间已被释放；③指针超过了变量的作用范围（重要）；④内存被其他数据改动（正常情况下不会出现此情况）;
  注：声明为全局变量的指针是会被初始化为NULL。
  void func() {
      int *ptr = nullptr;
      {
          int a = 10;
          ptr = &a;
      } // a的作用域到此结束
      int b = *ptr; // ptr指向a，a已经被回收，ptr野指针
  }
  ```

- 智能指针

  ```
  1）野指针最好的解决办法就是通过智能指针来代替普通指针的实现（智能指针被封装为一个栈对象，当生命周期退出的时候就根据引用计数判断是否需要释放堆上的内存)。
  2）shared_ptr：采用引用计数的方法，记录当前内存资源被多少个智能指针引用；当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。
  3）weak_ptr：share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。weak_ptr是一种不控制对象生命周期的智能指针, 它指向一个shared_ptr管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr，weak_ptr只是提供了对管理对象的一个访问手段。
  ```
  
- `指针`和`引用`适用的情况：

  ```
  1.如果数据对象是数组，则只能使用指针；
  2.如果数据对象是较大的结构体，则使用指针或者引用；
  3.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能造成内存泄漏；
  4.如果数据对象是类对象，则使用引用，保证指向唯一且不允许变量为空，而且提高了程序的运行效率；（如果我们将子类对象传递给需要超类对象的函数，如果按值传递则会对传递的对象进行切片，会输出超类的函数结果，因此在此时应使用引用。link:https://blog.csdn.net/stpeace/article/details/42113607）
  ```
  
- `指针`的大小不是都是`4字节`，这和操作系统的位数相关（CPU最大能处理的数据位数）。

- `指针常量`和`常量指针`的区别

  ```
  1）定义：文字表示了修饰符的位置，*前面的是对被指向对象的修饰，*后面的是对指针本身的修饰。
  指针常量：char ch='a'; char * const p1 = &ch;
  常量指针：char const * p1; const char * p1;
  2）记忆方法：const修饰谁，谁就不能变；const在前，修饰被指向对象；const在后，修饰指针；
  3）指针常量必须被初始化，指向对象需是普通字符（不能是常量字符，因为常量字符传过来的&static_ch是‘const char *’类型的，和指针常量的‘char *’类型冲突），且初始化之后不能更换地址，
  ```


- `堆`和`栈`的区别

  ```
  1）申请方式不同：栈由系统分配，堆是自己申请和释放；
  2）
  ```

- （静态）全局变量和（静态）局部变量的区别

  ```
  1.从存储位置和生命周期的角度：
  1）全局变量、静态全局变量、静态局部变量都存储在静态存储区，随主程序创建而创建，随主程序结束而结束；
  2）局部变量存储在栈空间，随着函数体的调用而被创建，随着函数体的结束而被回收。
  2.从作用域的角度：
  1）全局变量和静态全局变量具有全局作用域，全局变量可以作用于所有的源文件，而静态全局变量只能作用于定义它的源文件，即使两个源文件定义了相同的静态全局变量，它还是两个不同的变量；
  2）局部变量和静态局部变量具有局部作用域，局部变量只在函数执行期间存在，函数的一次调用结束后局部变量的内存被回收；而静态局部变量只被初始化一次，自从第一次初始化之后到程序运行结束都一直存在，它和静态全局变量的区别是，它只对定义自己的函数体可见；
  ```
  
- `static`的用法和作用

  ```
  1.static最重要的作用是：【限定变量或函数的作用域】。
  1）在模块中，static全局变量和static函数只能被这一模块内的其它函数调用，不能被模块外的其它函数调用。
  2）在类中，static成员变量属于整个类，对类的所有对象只有一份拷贝；static成员函数属于整个类，这个函数不接收this指针，因而只能访问static成员变量。
  2.static变量存储在静态存储区，在程序开始运行时被初始化，默认初始化为0。（特殊统计作用）
  3.在类中，static成员变量必须【在类内声明，在类外初始化】（静态常量成员可以在类内初始化，static const int a=0）；
  1）静态成员变量属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
  2）如果不在类外定义静态变量，调用[类名::静态变量名]会报‘未定义的引用’的错误，这是因为静态成员变量只被声明，而未被定义，即未被分配内存，显然是不能直接访问的。
  4.static修饰的成员变量在对象中不占用内存，因为它不是和对象在堆栈中生成的，它是在静态存储区中生成的。
  ```
  
- 结构体构造函数

  ```
  1）结构体内定义含参数列表的构造函数。如果使用了结构体数组，则必须再定义一个无参数的构造函数，或者将含参数的构造函数赋默认值。在建立结构体数组时如果只写了带参数的构造函数，将会出现数组无法初始化的错误；
  struct Node {
  	int x,y;
  	Node(int a=0, int b=0): x(a), y(b){}
  }
  或者
  struct Node {
  	int x,y;
  	Node(){}
  	Node(int a, int b): x(a), y(b){}
  }
  ```
  
- 初始化列表的作用

  ```
  1）类的构造函数使用初始化列表时，可以不调用默认的初始化构造函数，而是直接调用拷贝构造函数；
  2）必须使用初始化列表的时候：
  ①const常量成员：因为常量只能初始化不能赋值，所以必须放在初始化列表里面；
  ②引用类型：引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面；
  ③没有默认构造函数的类类型：因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化；
  3）成员变量初始化顺序是按照类中出现的顺序初始化，而不是依照在初始化列表中的顺序；
  参考：https://blog.csdn.net/lws123253/article/details/80368047
  代码：
  
  #include <bits/stdc++.h>
  using namespace std;
  
  class Test1 {
  public:
      int a;
      Test1() {
          cout << "default constructor of Test1" << endl;
      }
      Test1(Test1 &t1) {
          this->a = t1.a;
          cout << "copy constructor of Test1" << endl;
      }
      Test1& operator = (const Test1 &t1) {
          cout << "assignment for Test1" <<endl;
          this->a = t1.a;
          return *this;
      }
  };
  
  class Test2 {
  public:
      Test1 test1;
      Test2() {
          cout << "default constructor of Test2" << endl;
      }
  //    Test2(Test1 &t1) {
  //        test1 = t1;
  //    }
      Test2(Test1 &t1) : test1(t1) {} 
  };
  
  int main()
  {
      Test1 t1; // Test1默认构造函数
      Test1 t2 = t1; // Test1拷贝构造函数
      Test2 t3; // Test2默认构造函数
      Test2 t4(t1); // Test2拷贝构造函数，test1初始化，直接调用拷贝构造函数
      return 0;
  }
  ```

- 类`static`成员变量理解

  ```
  1.静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存；
  2.静态成员变量属于整个类，而不属于某个对象，所有对象可以共享整个静态成员变量；
  3.public静态成员变量访问方法，类名::成员名 | 对象名.成员名 | 指针->成员名 | 引用.成员名；而private静态变量访问方法，对象名.相关函数接口 | 类名::静态函数名。
  ```
  
- 判断题：`静态数据成员必须在类外定义和初始化`。答案：错误，静态成员变量类内声明，类外定义，没说一定要初始化。

- `static`成员变量要在类外定义或者初始化的原因

  ```
  1.静态成员是“类级别”的，也就是它和类的地位等同，而普通成员是“对象（实例）级别”的；类级别的成员，先于该类任何对象的存在而存在，它被该类所有的对象共享。
  2.必须在对象定义之前进行静态成员的定义。因为，如果在对象定义后再定义静态成员，这显然是不合适的。因为可能会出现静态成员重复定义的情况；就算不重复定义，也会产生竞争，从而造成死锁的问题，以至于对象无法创建。
  ```

- 声明只是表明了变量的数据类型和属性，并不分配内存；定义则是需要分配内存的。注意：如果在类里面这么写int a; 那么是既声明了变量，也定义了变量，两者合在一起了。静态成员是“类级别”的，也就是它和类的地位等同，而普通成员是“对象（实例）级别”的。 类级别的成员，先于该类任何对象的存在而存在，它被该类所有的对象共享。

- 类中`public`、`protected`和`private`修饰符的作用

  ```
  1.访问权限控制：
  1）public变量和函数，在类的内部和外部都可以访问；
  2）protected变量和函数，只能在类的内部和其派生类中访问进行访问（类的内部包括，类成员函数、友元函数或友元类）；
  3）private成员变量和函数，只能在类的内部被访问。
  // 无论派生方式是什么样子的，派生类永远能够访问到基类的公有部分和受保护部分，而永远不能访问基类的私有部分。
  // 对于struct和class我们知道，在定义的时候其中的成员如果没有注明访问权限，那么在class默认是private的，而在struct默认是public的。
  // 在派生的时候也如出一辙。没有注明派生方式，派生类是class的话默认方式是private，而派生类是struct的话，默认方式是public。
  // 默认的防控属性取决于子类而不是基类。因此，基类是struct，派生类是class，默认的继承方式是private的；基类是class，派生类是struct，默认的继承方式是public的。
  2.继承权限控制
  1）public继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, 子类不可见；
  2）protected继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, 子类不可见；
  3）private继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, 子类不可见。
  无论哪种继承方式，上面两点都没有改变：
  ①.private成员只能被本类成员（类内）和友元访问，不能被派生类访问；
  ②.protected成员可以被派生类访问。
  ```

- 面向对象的三大特征`封装`、`继承`和`多态`

  ```
  1.封装：通过封装将一部分成员隐藏起来，另一部分成员作为类或对象与外部的接口。从而控制数据的访问权限，并且能够减少程序中不同部分之间的相互影响。隐藏对象的属性和接口实现细节，仅仅对外提供接口和方法。
  优点：提高安全性，隔离影响。
  2.继承：在父类基础上创建派生类，可以通过增加、修改、替换父类成员产生派生类，对父类进行扩充，这种继承性使程序具有可重用性。子类可以从父类中获得同类的本质特征，并且增加个体特征，而不必完全重新定义。
  优点：提高代码重用性。
  3.多态：多态是在不同继承关系的类对象，去调同一函数，产生了不同的行为。【C++多态意味着调用同一名称成员函数时，会根据调用函数的参数中对象的类型来执行不同的函数。】
  优点：提高代码重用性，提高可扩展性。
  1）形成多态必须具备三个条件：
  ①必须存在继承关系；
  ②继承关系必须有同名虚函数（其中虚函数是在基类中使用关键字virtual声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数）；
  ③存在基类类型的指针或者引用，通过该指针或引用调用虚函数；
  2）多态包括：编译时多态、运行时多态；
  ①编译时多态是通过静态联编实现，通过函数重载和运算符重载实现；
  ②运行时多态是通过动态联编实现，通过函数覆盖实现。
  ```

- **重载**：在同一作用域中，同名函数的形式参数（参数个数、类型或者顺序）不同时，构成函数重载。

  ```
  1.函数返回值类型与构成重载无任何关系，不能作为区分重载的条件；
  2.类的静态成员函数与普通成员函数可以形成重载；
  3.函数重载发生在同一作用域，如类成员函数之间的重载、全局函数之间的重载；
  注意：在同一作用域中，函数同名且参数列表相同，但返回类型不同，不构成重载且程序会报编译错误。
  ```

- **const重载**

  ```
  // const函数重载
  class Base {
  public:
  	void funcA();			 //1
  	void funcA() const;		 //2
  	void funcB(int a);		 //3
  	void funcB(const int a); //4
  };
  x = 1, funcA(){return x;}, funcA() const{return x+1;};
  Baes a; const Base b;
  a.funcA(); // 1, b.funcA(); // 2
  在类D中funcA与const funcA是合法的重载，而两个funcB函数是非法的，不能通过编译。
  原因是：在类中，由于隐含的this形参的存在，const版本的function函数使得作为形参的this指针的类型变为指向const对象的指针，而非const版本的使得作为形参的this指针就是正常版本的指针。此处是发生重载的本质。
  调用规则：const对象默认调用const成员函数，非const对象默认调用非const成员函数；
  // const重载（变量）
  void func(char *a){cout << "non-const func()" << a;}  
  void func(const char *a){cout << "const func()" << a;}
  这两个函数构成重载，函数同名但参数列表不同，第一个中char *a指向一个字符串的指针，而const char *a指向一个字符串的常量指针。当函数是字符串变量时，调用第一个函数，而当参数为字符串常量时，调用第二个函数。
  void func(char *a){cout << "non-const func()" << a;}  
  void func(char * const a){cout << "const func()" << a;}
  这两个都是指向字符串变量，但第一个是指向一个字符串的指针，第二个是指针常量(本质常量，常量的值是指针)，这就和<int a>与<const int i>一样，会出现编译错误。
  ```

- **隐藏**：指不同作用域中定义的同名函数构成隐藏(不要求函数返回值和函数参数类型相同)。比如派生类成员函数隐藏与其同名的基类成员函数、类成员函数隐藏全局外部函数。`隐藏是一个静态概念，它代表了标识符之间的一种屏蔽现象，而覆盖则是为了实现动态联编，是一个动态概念。`

  ```
  对比覆盖和隐藏，不难发现函数覆盖其实是函数隐藏的特例。如果派生类中定义了一个与基类虚函数同名但是参数列表不同的非virtual函数，则此函数是一个普通成员函数，并形成对基类中同名虚函数的隐藏，而非虚函数覆盖。
  ```

- **重写/覆盖**：**派生类中与基类同返回值类型、同名和同参数的虚函数重定义，构成虚函数覆盖，也叫虚函数重写**。

  ```
  对比覆盖和隐藏，不难发现函数覆盖其实是函数隐藏的特例。如果派生类中定义了一个与基类虚函数同名但是参数列表不同的非virtual函数，则此函数是一个普通成员函数，并形成对基类中同名虚函数的隐藏，而非虚函数覆盖。
  ```

- `重载`、`隐藏`和`覆盖`的区别

  ```
  作用域区别、参数区别、关键字区别
  1.重载是在同一个类中，函数同名、参数列表不同（参数的类型、个数和排列顺序），构成重载；
  2.隐藏和覆盖出现在不同的类，基类和派生类中。其中，若函数同名、参数列表不同，构成隐藏，若函数同名、参数列表相同，且基类函数被virtual修饰则构成覆盖，否则构成隐藏（注意：派生类函数如果没用virtual修饰，也会构成覆盖）。其中，覆盖是隐藏的特例。
  ```


- `重载`和`覆盖`的区别

  ```
  1.overload（重载）是指编写一个与已有函数同名但是参数表不同的函数。重载不是一种面向对象的编程，而只是一种语法规则，重载与多态没有什么直接关系。
  	void test(int i);
    	void test(double i);// overload
    	void test(int i, double j);// overload
    	int test(int i); // 不能构成重载，会有编译错误。
  原因：函数重载不可以根据返回类型区分，因为int max(int a, int b)，float max(int a, int b)，调用 max(a, b) 编译器不知道调用的是哪个函数。
  2.override（覆盖）是指派生类重写基类的虚函数。重写的函数必须有一致的参数表和返回值（C++标准允许返回值不同的情况，但是很少有编译器支持这个特性）。
  ------
  1）范围区别：重载和被重载的函数在同一个类中，覆盖和被覆盖函数在不同类中（派生类和基类）；
  2）参数区别：重载和被重载函数参数列表一定不同，而覆盖和被覆盖函数的参数列表一定相同；
  3）修饰符区别：被覆盖函数的函数必须要有virtual修饰，而重载函数和被重载函数是否被virtual修饰随意。
  ```

- `隐藏`和`覆盖`、`重载`的区别

  ```
  隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
  1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
  2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。
  ------
  ①与重载的范围不同：隐藏和被隐藏函数在不同类中；
  ②参数的区别：隐藏和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被覆盖。如：
  class Base {
  public:
  　　virtual void f(float x){ cout << "Base::f(float) " << x << endl; }
  　　void g(float x){ cout << "Base::g(float) " << x << endl; }
  　　void h(float x){ cout << "Base::h(float) " << x << endl; }
  };
  class Derived : public Base {
  public:
  　　virtual void f(float x){ cout << "Derived::f(float) " << x << endl; }
  　　void g(int x){ cout << "Derived::g(int) " << x << endl; }
  　　void h(float x){ cout << "Derived::h(float) " << x << endl; }
  };
  通过分析可得：
  1) 函数Derived::f(float)覆盖了Base::f(float)。
  2) 函数Derived::g(int)  隐藏了Base::g(float)，不是重载。
  3) 函数Derived::h(float)隐藏了Base::h(float)，不是覆盖。
  例子：
  void main(void)
  {
  　　Derived d;
  　　Base *pb = &d;
  　　Derived *pd = &d;
  　　// Good : behavior depends solely on type of the object
  　　pb->f(3.14f); //运行结果: Derived::f(float) 3.14
  　　pd->f(3.14f); //运行结果: Derived::f(float) 3.14
  　　// Bad : behavior depends on type of the pointer
  　　pb->g(3.14f); //运行结果: Base::g(float) 3.14
  　　pd->g(3.14f); //运行结果: Derived::g(int) 3
  　　// Bad : behavior depends on type of the pointer
  　　pb->h(3.14f); //运行结果: Base::h(float) 3.14
  　　pd->h(3.14f); //运行结果: Derived::h(float) 3.14
  }
  请大家注意，f()函数属于覆盖，而g()与h()属于隐藏。从上面的运行结果，我们可以注意到【在覆盖中，用基类指针和派生类指针调用函数f()时，系统都是执行的派生类函数f()，而非基类的f()】，这样实际上就是完成的“接口”功能。而在隐藏方式中，用基类指针和派生类指针调用函数f()时，系统会进行区分，基类指针调用时，系统执行基类的f()，而派生类指针调用时，系统“隐藏”了基类的f()，执行派生类的f()，这也就是“隐藏”的由来。
  link: https://www.cnblogs.com/zhc-/p/3623189.html
  ```
  
- 虚拟继承的`sizeof`的问题

  ```
  1.普通继承派生类和基类公用一个虚函数表，只需要一个指针维护虚函数表；而对于虚拟继承，派生类和基类各自维护自己的虚函数表，即各自需要一个指针，并且派生类还需要一个指针指向基类虚函数表，其中存放的是偏移量。
  1）
  class a {
  	char s;
  	virtual void func();
  };
  class b: virtual a {
  	virtual void func();
  };
  class c: public a {
  	virtual void func();
  };
  其中，sizeof(a)大小是8，sizeof(b)大小是16，sizeof(c)大小是8;注意在类里面和结构体一样，存在内存对齐的情况，这里最大是指针4字节，因此按照4字节对齐。
  ```

- `虚函数`和`纯虚函数`的区别

  ```
  1）虚函数注意点：
  定义一个函数为虚函数，不代表函数为不被实现的函数。
  定义其为虚函数是为了允许用基类的指针来调用派生类的这个函数。
  定义一个函数为纯虚函数，才代表函数没有被实现。
  定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
  link: https://blog.csdn.net/weixin_43124720/article/details/118328485
  2）虚函数的“虚”体现在，一个类的函数调用不是在编译时被确定，而是在运行时被确定。编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数。
  3）纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求所有派生类都要定义自己的实现方法，如：
  	virtual void func()=0;
  4）基类的纯虚函数要求派生类重新声明该函数，否则该派生类不能被实例化。这样设计的意义是告诉派生类的设计者，必须提供这个纯虚函数的实现，虽然基类中只是声明。
  5）包含纯虚函数的类是不能被实例化的。例如，基类有纯虚函数，基类不能被实例化。
  ```

- 友元函数的理解

  ```
  类的友元函数是在类内声明，在类外定义。有权访问类的私有成员和保护成员。尽管友元函数在类中，但是其不是成员函数，是普通函数。友元保护友元函数和友元类，声明方法是在类中的函数或者类前添加修饰符“friend”，如下：
  class A{
  private:
  	int x;
  public:
  	friend void func(A a); // 类的对象做参数，可以访问类的成员。 
  }
  1.为什么要引入友元函数：在实现类之间数据共享时，减少系统开销，提高效率；
  2.什么时候使用友元函数：①运算符重载的某些场合需要使用友元，②两个类要共享数据的时候；
  3.友元函数的位置：友元函数是不是类成员函数，所以放在类的公有段和私有段没有区别；
  4.一个函数可以是多个类的友元函数，只需要在各个类中分别声明。
  link: https://www.cnblogs.com/balingybj/p/4778247.html
  ```

- 内联函数

  ```
  引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：
  1）在内联函数内不允许使用循环语句和开关语句；
  2）内联函数的定义必须出现在内联函数第一次调用之前；
  3）【在类定义中的定义的函数都是内联函数，即使没有使用inline说明符。当然，是否内联还是取决于编译器，而在类外定义的成员函数就不是内联函数。】
  4）在类中声明的成员函数如果没加inline，而在类外定义该成员函数时加了inline，该成员函数也为内联函数。综上所述，不管是声明还是定义，只要看见有inline，都为内联。
  ```
  
- 类的构造函数和析构函数

  ```
  1.类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。
  2.类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
  class Line {
  private:
        double length;
  public:
        Line();   // 这是构造函数声明
        ~Line();  // 这是析构函数声明
  };
  // 成员函数定义，包括构造函数
  Line::Line(void) {
      cout << "Object is being created" << endl;
  }
  Line::~Line(void) {
      cout << "Object is being deleted" << endl;
  }
  ```

- 结构体的构造函数

  ```
  struct ListNode {
  	int val;
  	struct ListNode *next;
  	ListNode(): val(), next() {}
  	ListNode(int value, ListNode *p_next = nullptr): val(value), next(p_next) {}
  //	ListNode(int value, ListNode *p_next = nullptr) // 等价
  //	{
  //	    val = value;
  //	    next = p_next;
  //	}
  };
  
  ListNode node;
  node = {1, nullptr}; // 无参默认结构体构造体函数
  node = ListNode();   // 有参数结构体构造函数 
  ```
  
- 内联函数和宏定义的区别

  ```
  1）宏定义在编译前进行字符串替换；内联函数在编译时进行参数检查，且具有返回值；
  2）内联函数在编译时将函数代码嵌入到目标代码中，省去函数调用的开销，并且进行参数类型检查，具有返回值，可以实现重载；
  3）宏定义要注意书写，参数要括起来，否则会造成歧义，内联函数不会产生歧义；
  4）内联函数有参数类型检测、语法判断等功能，而宏定没有；
  ```
  
- 什么情况下会调用拷贝构造函数？注意：`编译器自行构造的临时对象一定是const类型的。`

  ```
  1）用同一个类的一个实例化对象去初始化另一个对象；
  2）函数的参数是类的对象（非引用传递）；
  3）当函数的返回值是类的对象或引用时，由于返回值是值传递的，所以会在返回值的地方调用拷贝构造函数。
  ```
  
- 静态变量什么时候初始化？

  ```
  1）在C中，静态局部变量初始化发生在代码执行之前，编译阶段分配好内存就初始化，所以无法用变量对静态局部变量进行初始化；而在C++中，静态局部变量在执行相关代码时才会初始化，并通过atexit()进行关联，所以可以用变量对静态局部变量进行初始化。
  ```
  
- 什么是内存泄漏？如何避免？

  ```
  内存泄漏一般指的是堆内存的泄漏，使用完后必须显示的释放，否则这块内存就不能再次使用，造成内存泄漏。
  1）计数法，使用new/malloc时，计数加1，使用delete/free时，计数减1，结果不为0则表示存在内存泄漏；
  2）对象数组的释放使用delete[]；
  3）将基类的析构函数声明为虚函数（因为A *p=new B;析构时调用基类的析构函数没有调用派生类的析构函数，从而造成内存泄漏）；
  4）保证new/delete，malloc/free成对出现。
  link: https://blog.csdn.net/qq_34276797/article/details/116765142
  ```
  
- 为什么基类的析构函数是虚函数？

  ```
  1）在实现多态时，用基类指针操作派生类对象，防止在析构时只析构基类而不析构派生类的情况发生；
  2）当基类的析构函数被定义为虚函数时，用基类指针操作派生类及对象时，进行析构过程是：先释放派生类资源再释放基类资源；如果基类的析构函数不是虚函数，用基类指针操作派生类及对象时，会调用基类虚函数不会调用派生类虚函数；
  3）如果不需要基类对派生类及对象进行操作，则不需要将析构函数定义为虚函数，因为这样会给类添加一个虚函数表，存放虚函数指针，会增加内存消耗。
  ```

- 静态变量什么时候初始化？

  ```
  1）静态变量存放在全局存储区，在主程序之前，编译器已经为其分配好了内存；但是在C和C++中，初始化的节点不一样。在C中，静态变量在编译阶段分配好内存之后就会进行初始化，所以【无法使用变量对静态局部变量进行初始化】。而在C++中，静态全局变量在编译阶段分配好内存之后就会进行初始化，而静态局部变量在第一次使用时分配内存并初始化，所以在C++中可以【使用变量对静态局部变量进行初始化】。
  2）造成差异的原因是C++中引入了对象，要进行初始化要执行相应的构造函数和析构函数；
  3）初始化分为：①静态初始化，使用常量来对变量进行初始化；②动态初始化，调用函数进行初始化，如int a=func()，或者类初始化调用构造函数。这些变量会在mian函数执行之前完成。
  ```
  
- 对象创建时的代码加载顺序为：`静态代码，非静态代码，构造方法`。若继承了父类，则加载顺序为：`父类的静态代码，子类的静态代码，父类内部的非静态代码，父类的构造方法，子类的非静态代码，子类的构造方法`。其中，静态代码包括（静态方法，静态变量，静态代码块等），非静态代码即（成员方法，成员变量，成员代码块等），同一种代码，写在上面的先加载。

- `虚继承`：目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类，本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。例如，如果在菱形继承中，使用类A的成员变量就会造成命名冲突。

  参考链接：http://c.biancheng.net/view/2280.html
  
- 类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？

  ```
  1）都是通过构造函数初始化，一种是赋值初始化（在函数体内进行赋值初始化），另一种是列表初始化（在冒号后使用参数列表进行初始化）。区别在于赋值初始化发生在所有数据成员被分配内存后才进行的，而列表初始化发生在给数据成员分配内存时就进行的，初始化这个数据成员函数体还未被执行。
  2）派生类构造函数执行顺序：①调用虚拟基类的构造函数；②调用基类的构造函数，调用顺序按照继承时声明的顺序；③派生类的成员对象调用各自类的构造函数；④派生类自己的构造函数；
  class A{
  public: A(int i) {cout << "call class A " << i << endl;}
  };
  class B{
  public: B(int i) {cout << "call class B " << i << endl;}
  };
  class C{
  public: C(int i) {cout << "call class C " << i << endl;}
  };
  class D: public A, public C, public B{
  public:
  	D(int a, int b, int c, int i): A(a), a1(a), b2(b), c3(c), B(b), C(c) { 
  		cout << "call class D " << i << endl;
  	}
  		cout << "call class D " << i << endl;}
  	A a1; B b2; C c3;
  };
  int main() {D obj(1, 2, 3, 4); return 0;}
  // result 1
  call class A 1 // 基类调用各自的构造函数
  call class C 3
  call class B 2 
  call class A 1 // 派生类对象调用所属类的构造函数
  call class B 2
  call class C 3
  call class D 4 // 派生类调用自己的构造函数
  class D: public A, public C, virtual public B{
  public:
  	D(int a, int b, int c, int i): A(a), a1(a), b2(b), c3(c), B(b), C(c) { 
  		cout << "call class D " << i << endl;}
  	A a1; B b2; C c3;
  };
  // result 2
  call class B 2 // 虚拟继承基类的构造函数
  call class A 1 // 基类的构造函数
  call class C 3
  call class A 1 // 派生类对象的构造函数
  call class B 2
  call class C 3
  call class D 4 // 派生类自己的构造函数
  ```
  
- C++返回字符串函数，有四种方式：

  ```
  1.使用堆空间，返回申请的堆地址，注意释放;
  2.函数参数传递指针，返回该指针;
  3.返回函数内定义的静态变量（共享）;
  4.返回全局变量;
  ```
  
- 程序在内存中的分段

  ```
  1、代码段/只读段：二进制指令、字符串字面值，具有const属性且被初始化过的全局、静态变量。
  2、数据段：被初始化过的全局变量和静态变量。
  3、bss段：未被初始化过的全局变量和静态变量，进程一旦加载成功，就会把这段内存清理为零。
  4、堆：动态的分配、管理，需要程序员手动操作。有低地址向高地址拓展
  5、栈：非静态的局部变量，包括函数的参数、返回值。由高地址向低地址拓展
  从高地址向低地址使用，和堆内存之间存在一段空隙.
  堆区和栈区中间存在一块间隙，一方面是为堆和栈增长预留空间，另一方面存放共享库、共享内存。
  参考：https://blog.csdn.net/zgdzjzz/article/details/98877073
  ```
  
- 程序执行的过程

  ```
  1.预编译：展开宏定义，处理预编译指令，删除注释，添加行号和文件标识；
  2.编译：对预处理的文件进行词法分析、语法分析、语义分析，优化后生成汇编代码文件；
  3.汇编：将汇编代码转变为机器指令；
  4.链接：将各个模块组装起来，生成装入模块，链接后形成完整的逻辑地址；（静态链接、装入时动态链接（判断模块是否需要装入）、运行时动态链接）
  5.装入：将装入模块装入内存，装入后形成物理地址；（绝对装入、可重定位装入（静态重定位）、动态运行时装入（动态重定位））
  1）静态重定位：一个作业在装入内存时，必须分配其所需的全部内存空间；在程序运行期间不能再移动，也不能再申请内存空间；
  2）动态重定位：系统会设置一个重定位寄存器，存放装入模块的起始地址（物理地址=逻辑地址+寄存器存放的起始地址）。允许程序在内存中移动，允许程序分配不连续的存储区，允许动态申请内存，允许程序段的共享。
  ```
  
- 面试tips

  ```
  1.写一个快速排序
  2.Java GC原理
  3.C++纯虚函数、虚函数
  4.怎么用子类调用特属于父类的虚函数
  5.C++变量的存储类型
  ```

### 操作系统

- ##### 进程线程区别

  ```
  1）调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。
  2）并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。
  拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。
  3）系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。
  参考：https://wiki.mbalib.com/wiki/线程/
  ```
  
- ##### 句柄

  ```
  1）句柄是由操作系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。它是一种智能指针，用户程序要引用系统所管理的内存块或对象时，就要使用句柄。这种间接访问的方式可以防止用户随意读写系统的对象。
  2）在程序设计中,句柄是一种特殊的智能指针。当一个应用程序要引用其他系统(如数据库、操作系统)所管理的内存块或对象时，就要使用句柄。句柄与普通指针的区别在于：指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。
  3）用一种形象的说法可以表述为：有一个固定的地址（句柄），指向一个固定的位置（区域A），而区域A中的值可以动态地变化，它时刻记录着当前时刻对象在内存中的地址。
  4）设计这么一个句柄的原因在于：句柄可以防止用户随意读写操作系统内核的文件对象。
  ```
  
- ##### 管道

  ```
  管道通常指无名管道，是UNIX系统IPC最古老的形式。
  特点有：
  1、它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
  2、它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间），实现依赖父子进程文件共享。
  3、它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。
  1）无名管道:管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。
      单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
      数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。（有点像队列哈）
  2）有名管道：不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。
  ```

- ##### CPU的上下文切换

  ```
  1）CPU上下文：CPU的寄存器（CPU内置的内存）和程序计数器（存储CPU正在执行的指令位置、或即将执行的下一条指令位置）；
  2）CPU上下文切换：保存前一个任务的CPU上下文（也就是 CPU 寄存器和程序计数器），加载下一个任务的上下文，再跳转到程序计数器所指的新位置，运行新任务；
  ①.CPU寄存器：是CPU内置容量小，但是速度极快的内存；
  ②.程序计数器：是用来存储CPU正在执行指令的位置，或执行下一条指令的位置；
  3）类型：进程上下文切换、线程上下文切换、中断上下文切换；
  ```
  
- ##### 系统调用（系统调用实际上最终是中断机制实现的）

  ```
  进程从用户态切换到内核态，需要通过系统调用来完成。比如，读取文件的过程：
  ①保存CPU原来用户态的指令位置；
  ②为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置；
  ③跳转到内核态运行内核任务；
  ④系统调用结束，CPU寄存器恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。
  一次系统调用，发生了两次CPU上下文切换，用户态-内核态-用户态。
  ```

- ##### 进程上下文切换跟系统调用区别

  ```
  1）系统调用都是在同一个进程中发生，进程由用户态到内核态再到用户态的转变；
  2）进程上下文切换是从一个进程切换到另一个进程中运行；
  3）进程上下文切换除了需要保存虚拟内存、栈和全局变量等用户空间资源，还包括内核堆栈，寄存器等内核空间的状态；
  参考：https://blog.csdn.net/never_compromise2580/article/details/84593606
  ```

- ##### 进程上下文切换的时机

  ```
  进程由运行态转变为就绪态、阻塞态的几种情况：
  1）分配给当前进程的时间片耗尽，进程被挂起，切换到其它等待的进程；（进入就绪态）
  2）系统申请的资源（如内存）不足；（进入阻塞态）
  3）调用Sleep函数主动挂起进程；
  4）当有优先级更高的进程运行时，当前CPU上的进程会被挂起；
  5）发生硬件中断，当前进程会被中断挂起，转而执行内核中的中断服务程序；
  ```

- ##### 线程上下文切换

  ```
  1）两个线程属于不同进程，资源不共享，等同于进程切换；
  2）两个线程属于同一进程，只需要切换私有数据、寄存器等不共享数据；
  ```

- ##### 中断上下文切换

  ```
  与系统调用不同，中断上下文切换不涉及进程的用户态。所以中断过程打断了一个正处于用户态的进程，也不需要保存和恢复这个进程的虚拟内存、栈和全局变量等用户资源。它只包括内核态中断服务程序执行所必须的状态：CPU寄存器、内核堆栈、硬件中断参数;
  ```

- ##### 用户态切换到内核态的三种方式

  ```
  1）系统调用：用户进程从用户态切换到内核态的方式；
  2）异常：执行用户程序发生异常，会触发当前进程切换到处理次异常的相关内核程序，也就转换到了内核态；
  3）外围设备的中断：当外围设备完成用户的请求操作后（打印机完成，磁盘读写完成），会向CPU发出相应的中断信号，此时CPU会暂停执行下一条即将执行的指令转而处理中断信号对应的处理程序。
  ```

- ##### 进程：作为系统资源分配的基本单位（内存地址空间、外围设备如打印机）

  ```
  1）进程的状态：运行态、就绪态、阻塞态（申请资源或者等待请求事件发生，主动行为）、创建态、终止态，此外还有挂起态（就绪挂起态、阻塞挂起态）
  ①创建进程：系统为进程创建和初始化进程控制块（PID、进程状态标志、程序段、数据段等）
  ②进程撤销：进程运行结束或者出现异常，需要撤销进程。需要完成对分配给进程的资源的回收，撤销进程的PCB。
  2）进程控制相关的原语：①更新PCB中的信息（修改进程程序标志、将运行环境保存到PCB、从PCB中恢复运行环境）；②将PCB插入合适的队列；③分配/回收资源。
  3）进程的创建：
  ①创建原语：申请空白PCB；为进程分配所需资源；初始化PCB；将PCB插入就绪队列；
  ②引起进程创建的事件：用户登录、作业调度、提供服务、应用请求。
  4）进程的终止：
  ①撤销原语：从PCB集合中找到终止进程的PCB；若正在运行则剥夺CPU，将CPU分配给其他进程；终止所有子进程；将进程拥有的资源归还给父进程或操作系统；删除PCB。
  ②引起进程终止的事件：正常结束、异常结束、外界干预
  ```
  
- ##### 进程（执行的程序）在内存中的数据段

  ```
  1）按照进程在内存中的地址由低到高的顺序：
  ①.代码段（text）：又称文本段，存储可执行文件的指令，也有可能包含一些只读的常数变量，例如字符串变量；
  ①.数据段（data）：用于存放程序中初始化不为0的全局变量和静态变量的一块内存区域；
  ③.BSS段：用于存储程序中未初始化或初始化为0的变量的一块内存区域；
  ④.堆段(heap)：用于存放程序运行中被动态分配的内存段，大小不固定，可动态申请和释放；
  ⑤.栈段(stack)：用于存放程序临时创建的局部变量。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。
  2）五大区：
  ①.栈区：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
  ①.堆区：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 
  ③.全局区（静态区）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
  ④.文字常量区：常量字符串就是放在这里的。程序结束后由系统释放。
  ⑤.程序代码区：存放函数体的二进制代码。
  参考：https://blog.csdn.net/ganpengjin1/article/details/38269989
  ```
  
- ##### 进程的状态于转换

  ```
  1）五状态模型：创建态、就绪态、运行态、阻塞态、终止态（如考虑七状态模型，包括就绪挂起态和阻塞挂起态）；
  2）状态转换过程。
  ```
  
  <img src="C:\Users\RanchoY\OneDrive\A面试准备\IMG\process_status.png" alt="process_status" style="zoom:80%;" />
  
  <img src="C:\Users\RanchoY\OneDrive\A面试准备\IMG\process_status_change.png" alt="process_status_change" style="zoom:80%;" />
  
- ##### 进程间的通信方式：主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存）、Socket套接字。（Inter-Process Communication，进程间通信）

  ```
  1）管道通信（匿名管道和有名管道）：管道是用于连接读写进程的一个共享文件（在内存中开辟的一个固定大小的缓冲区），其采用半双工的通信方式，各进程互斥的访问管道。
  2）共享内存：不同的进程互斥的访问共享空间，包括基于数据结构的共享和基于存储区的共享；
  3）消息队列：进程间的数据交换以格式化的消息为单位，通过系统“发送/接收消息”两个原语进行数据交换。消息头包括：发送进程ID、接收进程ID、消息类型、消息长度等格式化信息（网络报文）。消息传递的方式包括直接通信方式和间接通信方式。直接通信方式：每个进程都有一个消息缓冲队列；间接通信方式：消息发送到中间体（信箱）；
  4）信号量：
  5）套接字：主要用于不同设备间的进程通信；
  ```
  
- ##### 匿名管道和有名管道的区别

  ```
  1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。
  2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
  3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。
  4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。
  参考：https://www.jianshu.com/p/c1015f5ffa74
  ```
  
- ##### Linux信号机制(最大意义是提供一种异步通信方式)

  ```
  1）定义：信号是一种软中断，信号机制是进程间的一种通信方式，采取异步通信方式，用来提醒进程的一个事件已经发生；
  2）信号来源：①硬件，用户输入、程序异常（内存非法访问）；②软件，系统调用，发送singal信号，kill()、abort()等；程序异常，内存非法访问；
  3）信号处理方式：默认处理方式、忽略处理方式、捕获并处理方式；
  4）分类：可靠信号/不可靠信号(实时信号/非实时信号)，不可靠信号不支持排队，多层发送系统不可靠信号，进程只能收到一次；可靠信号，支持排队，信号不会丢失；
  5）在进程的task_struct结构体中有一个未决信号的成员变量(struct sigpending pending)，每个信号在进程中注册都会把信号值加入到进程的未决信号集；
  6）信号生命周期：生命周期，目标进程产生信号》接收进程注册信号》接收进程注销信号》接收进程处理信号；
  7）信号注销：不可靠信号注销，删除sigqueue中的节点，将位图对应的标志清零；可靠信号注销，删除该信号在sigqueue中的所有的节点，后将位图对应的标志位清零；
  struct sigpending {
  	struct sigqueue *head, *tail; // 指向sigqueue类型的结构链表
  	sigset_t signal; // 信号标志位，所有的未决信号集
  };
  struct sigqueue {
  	struct sigqueue *next;
  	siginfo_t info;
  };
  8）处理时机：内核态》Signal信号处理》用户态
  9）信号捕捉的流程：
  ①在主函数中进入内核态（因系统调用、中断或异常）；
  ②从内核态转用户态时检测是否有信号等待处理；
  ③如果信号处理需要调用自定义的信号处理函数，则返回用户态，执行处理函数；否则，执行默认处理函数或者忽略；
  ④信号处理函数执行完毕，通过系统调用sigreturn，返回内核态，将相应的未决信号从链表中删去；
  ⑤信号处理完毕，调用sys_sigreturn返回主函数被中断的地方，继续执行下面的语句；
  参考：http://gityuan.com/2015/12/20/signal/
  参考：https://wushifublog.com/2020/05/16/深入理解Linux内核——signals/
  ```
  
  <img src="C:\Users\RanchoY\OneDrive\A面试准备\IMG\signal-handler.png" alt="signal-handler" style="zoom:20%;" />
  
- ##### 进程调度算法

  ```
  1）先来先服务调度算法（first-come first-served,FCFS）：
  2）短作业优先调度算法（short job first,SJF）：
  3）优先级调度算法（priority-scheduling algorithm,PSA）：
  4）高响应比优先调度算法：响应比=(等待时间+要求服务时间)/要求服务时间；
  5）最短剩余时间优先算法：当一个新作业达到时，其运行时间与当前进程的剩余运行时间进行比较，如果所需时间更小，则挂起当前进程转而执行新进程；
  6）时间片轮转算法：将所有就绪进程按照先进先出顺序排成一个队列，每次调度时把CPU时间分配给首进程，该进程执行一个时间片。当时间片用完时，计时器发出时钟中断，调度程序停止该进程的执行，并将它送往就绪队列末尾，同时继续吧CPU时间分配给队首进程；
  7）多级反馈队列算法：一个进程需100个时间片，对于时间片轮转算法进程需切换100次。多级队列算法设计了多个队列，每个队列的时间片不同，在第一个队列没执行完，就会被移到下一、个队列。
  参考：https://www.codenong.com/cs107034966/
  ```
  
- ##### 按中断的功能来分，中断有哪几种类型？

  ```
  按中断功能分类：
  1）输入输出中断：输入输出中断时当外部设备或通道操作正常结束或发生某种错误时发生的中断。例如：I/O传输出错、I/O传输结束等。
  2）外中断：对某中央处理机而言，他的外部非通道式装置所引起的中断称为外部中断。
  例如：时钟中断、操作员控制台中断、多机系统中CPU到CPU的通信中断。
  3）机器故障中断：当机器发生故障时所产生的中断叫硬件故障中断。例如:电源故障、通道与主存交换信息是主存储错、从主存取指令出错、取数据错、长线传输时的奇偶校验错等。
  4）程序性中断：在现行程序执行过程中，发现了程序性的错误或出现了某些程序的特定状态而产生的中断称为程序性中断。这些程序性错误有定点溢出、十进制溢出、十进制数错、地址错、用户态下用核态指令、越界、非法操作等。程序的特定状态包括逐条指令跟踪、指令地址符合跟踪、转态跟踪、监视等。
  5）访管中断：对操作系统提出某种需求（如请求I/O传输、建立进程等）时所发出的中断称为访管中断。
  ```

- ##### 进程、线程和协程的理解

  ```
  1）定义：进程是资源分配的基本单位，线程进程中执行运算的最小单位/执行处理机调度的基本单位，协程是线程内部调度的基本单位（用户态轻量级线程）；
  2）并发性：不同进程执行切换实现并发，各自占用CPU实现并行；一个进程内的多个线程并发执行；同一时间只能执行一个协程，其它处于休眠状态，适合对任务进行分时处理；
  3）进程拥有资源，线程不拥有资源，但一个进程的多个线程可以共享属于进程的资源；
  4）拥有资源情况：进程拥有CPU资源、内存资源、文件资源和句柄等，线程拥有程序计数器、寄存器、栈和状态字，协程拥有自己的寄存器和上下文栈；
  5）系统开销：线程的创建和销毁只需要处理PC值、状态码、通用寄存器、线程栈及栈指针即可；进程的创建和销毁需要重新分配及销毁task_struct结构；
  6）协程本质上还是线程，它是由虚拟机创建的。
  ```

- ##### 线程：处理机调度的基本单位

  ```
  1）组成部分：线程ID、线程控制块TCB
  2）运行状态：就绪态、运行态、阻塞态
  3）协程切换：同一进程线程切换不会引起进程切换、不同进程的线程切换回引起进程切换；
  4）实现方式：用户级线程（用户程序管理）和内核级线程（操作系统管理）；
  注意，内核级线程才是处理机分配的基本单位。
  5）多线程模型：多对一模型（优点，多个用户级线程的切换在用户空间完成，不需要切换到核心态，系统开销小；缺点，一个用户线程被阻塞，整个进程都会被阻塞，并发度不高。）。一对一模型（优点，并发能力高；缺点：一个用户进程会占用多个内核级线程，线程切换由系统内核完成，线程管理成本高开销大。）。多对多模型（集二者所长）。
  ```
  
- ##### 处理机调度

  ```
  1）调度算法：先来先服务调度、优先级调度、最短剩余时间调度、高响应比调度、时间片轮转算法、多级反馈队列算法；
  2）高级调度（作业调度，外存》内存，面向作业）：按照规则从后备队列选择合适的作业从后备队列（硬盘）调入内存，并为其创建进程；（无》创建态》就绪态）
  3）中级调度（内存调度，外存》内存，面向进程）：按照规则从挂起队列重要选择合适的进程将其数据调回内存；（挂起态》就绪态，或者，阻塞挂起>阻塞态）
  4）低级调度（进程调度，内存》CPU，面向进程）：按照规则从就绪态中选择一个进程为其分配处理机。（就绪态》运行态）
  ```
  
- ##### 进程调度（低级调度）

  ```
  1）进程调度的时机：
  ①进行进程调度的时机：当前进程主动放弃处理机（正常终止、发生异常、主动请求阻塞）；当前进程被动放弃处理机（时间片用完、更紧急的事情如I/O中断、更高优先级的进程进入就绪队列）
  ②不能进行进程调度的时机：在处理中断的过程中、进程在操作系统的内核程序临界区（访问临界资源时，被上锁，需等访问完临界区，再进行进程切换，如就绪队列临界资源（内核数据结构）。但是，普通临界资源的进程是可以进行调度与切换的）、在原子操作过程中。
  2）进程调度方式：非剥夺式调度、剥夺式调度。
  3）进程切换（有代价的）：①对原来运行进程各种数据的保存；②对新的进程各种数据的恢复（程序计数器、程序状态字、各种寄存器等处理机现场信息、这些一般保存在PCB）。
  ```
  
- 

- ##### 协程（Coroutine）：`协程只有和异步IO结合起来才能发挥出最大的威力。`

  ```
  1）协程运行在线程之上，当一个协程执行完成之后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程；
  2）协程之间的状态切换，在用户态完成，切换代价比线程从用户态到内核态的代价小很多；
  3）一个线程运行，不存在写变量冲突，控制共享资源不需要加锁，只需要加状态判断，所以执行效率比多线程高很多；
  注意事项：
  1）协程在调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态（操作系统只知道线程），当前协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度；
  解决方法：
  1）协程在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完之后，协程再去读取结果，类似于多线程；
  2）对系统的IO进行封装，改成异步调用的方式，需要大量的工作，希望编程语言原生支持；
  适用场景：
  1）在有大量IO操作的情况下，采用协程替换线程，可以达到很好的效果。一是降低的系统内存，而是减少了系统切换的开销，因此系统性能提升；
  2）调用协程尽量不用调用阻塞IO的方法，比如打印、读取文件、Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集的任务中才会发挥作用。
  异步IO：程序不因执行IO操作而被阻塞，就说程序是异步的。
  ```

- ##### 编程或者架构模型种类：阻塞、轮询、阻塞回调、异步回调

  ```
  1）阻塞：A调用B后，一直等着B返回结果；
  2）轮询：A调用B后，A不断去B那里查询返回结果；
  3）阻塞回调：A调用B后，A什么都不做，直到B通知A已完成；
  4）异步回调：A调用B后，该干啥干啥，B通知A已完成后，再继续处理该任务的后续任务；
  注意：异步回调，A需要告诉B需要干什么（参数），以及执行完后需要执行什么操作（回调函数func）;
  ```

- ##### 信号量机制

  ```
  进程互斥的三种硬件实现方式(中断屏蔽方法、TS/TSL指令、Swap/XCHG指)
  进程互斥的四种软件实现方式(单标志法、双标志先检査、双标志后检査、Peterson算法)
  1）在双标志先检査法中,进入区的“检査”、“上锁”操作无法一气呵成,从而导致了两个进程有可能同时进入临界区的问题；
  2）所有的解决方案都无法实现“让权等待；
  用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便是实现进程互斥、进程同步。
  1）信号量就是一个变量，可以用一个信号量来表示系统中某种资源的数量；
  2）原语是一种特殊的程序段,其执行只能一气呵成,不可被中断；
  3）一对原语，waits(S)原语和signal(S)原语，通常简称为P、V操作，代表“申请”和“释放”操作。
  1.信号量种类：整形信号量、记录型信号量。
  1）整形信号量：用一个整数型的变量作为信号量,用来表示系统中某种资源的数量。
  2）记录型信号量：整型信号量的缺陷是存在“忙等”问题,因此人们又提岀了“记录型信号量”,即用记录型数据结构表示的信号量。
  3）整形信号量：存在问题，不满足“让权等待原则”，会发生“忙等”；
  int S = 1;
  void wait(int S){ // 申请
  	while(S <= 0) {
  		资源不够，阻塞等待; // 存在问题：不满足“让圈权等待”原则，会发生“忙等”
  	}
  	S = S - 1;
  }
  void single(int S) { // 释放
  	S = S + 1;
  }
  4）记录型信号量：可以实现系统资源的申请和释放，可以实现进程的互斥和同步。value的意义是，当value>0表示系统可用资源的数目，当value<0表示信号量S上等待的进程数。
  struct {
  	int value; // 剩余资源数!!!!!!
  	struct process *L; // 等待队列
  } semaphore;
  void wait(semaphore S) { // 申请
  	S.value--;
  	if(S.value < 0) { // 满足条件，表示资源已经分配完毕，使用block原语使进程从运行态进入阻塞态，并把进程挂到信号量S的等待队列。可见改机制遵循了“让权等待”原则，不会出现忙等现象。
  		block(S.L);
  	}
  }
  void single(semaphore S) {
  	S.value++;
  	if(S.value <= 0) { // 满足条件，表示依然有进程在等待该类资源，因此调用wakeup原语换醒等待队列的第一个进程，被唤醒进程从阻塞态进入就绪态；
  		wakeup(S.L);
  	}
  }
  2.互斥信号量和同步信号量
  1）互斥信号量的初始值一般是1，因为两个进程之间的缓冲区通常是一个。
  2）同步信号量的初始值一般是0，
  ```

  <img src="C:\Users\RanchoY\OneDrive\A面试准备\IMG\semaphore.png" alt="semaphore" style="zoom: 30%;" />

- 自旋锁和信号量

  ```
  
  ```

- 生产者消费者问题

  ```
  系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。
  1）只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待；（同步）
  2）只有缓冲区不为空时，消费者才能从中取出产品，否则必须等待；（同步）
  3）缓冲区是临界资源，各进程必须互斥的进行访问；（互斥）
  问题1：如何使用信号量机制（P、V操作），实现生产者、消费者进程的这些功能？信号量机制可以实现互斥（设置初值为1的互斥信号量）、同步（设置初值为0的信号量，实现“一前一后”）、对一类系统资源进行申请和释放（设置一个信号量，初值为资源的数量，本质上也属于同步问题，若无资源则等待别的进程释放资源才继续往下执行）。
  semaphore mutex = 1; // 互斥信号量，实现对缓冲区互斥访问
  semaphore empty = n; // 同步信号量，表示空闲缓冲区数量
  semaphore full = 0;  // 同步信号量，表示产品数量，即非空缓冲区数量
  
  void Producer() {
  while(true){
  	create_product(); // 生产一个产品;
  	P(empty);
  	P(mutex);
  	num_product++; // 将产品放入缓冲区;
  	V(mutex);
  	V(full);
  }}
  
  void Consumer() {
  while(true) {
  	P(full);
  	P(mutex);
  	num_product--; // 从缓冲区取出一个产品;
  	V(mutex);
  	V(empty);
  	use_product(); // 使用产品
  }}
  问题2：能否改变相邻的P、V操作的顺序？
  1）对于P操作改变情况，①生产者，P(mutex)->P(empty)，消费者，P(mutex)->P(full)。若此时缓冲区已经放满产品（empty=0，full=n），则生产者进程执行P(mutex)使mutex=0，由于没有空闲缓冲区，因此生产者进程被阻塞。由于生产者进程阻塞，因此切换回消费者进程，先执行P(mutex)，由于mutex-0，其不被允许访问缓冲区，生产者进程没有释放临界资源的锁，消费者进程也被阻塞。这就造成了生产者进程等待消费者进程释放空闲缓冲区，消费者进程等待生产者进程释放缓冲区访问权限，出现“死锁现象”。
  2）若此时缓冲区为空（empty=n,full=0），按照先消费者P(mutex)->P(full)，后生产者P(mutex)->P(empty)。消费者进程等待生产者进程生产产品，生产者进程等待消费者进程释放缓冲区访问权限，出现“死锁”现象。
  注意点：
  1）实现互斥是在同一进程中进行PV操作，而实现同步是在不同的两进程，一个实现P操作另一个实现V操作；
  2）实现互斥P操作一定要放在实现同步P操作之后，否则会发生“死锁”现象；
  3）生产产品和使用产品都是放在PV操作之外的，一般不放在它们之间，因为这样会导致访问临界区的时间增加，会导致其它进程被阻塞，并发度降低。
  ```

- 瞌睡的理发师问题

  ```
  1）描述：理发店里有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子。如果没有顾客，理发师便在理发椅上睡觉；当一个顾客到来时，它必须叫醒理发师；如果理发师正在理发时又有顾客来到，那么，如果有空椅子可坐，顾客就坐下来等待，否则就离开理发店。
  2）理解：①理发师：没有顾客时，睡觉（同步）；②顾客：在普通椅子上等待理发师空闲（同步）；③理发椅子只能有一个人（互斥）；注意，顾客有普通椅子则等待，没有则离开（不构成同步）。
  3）变量：定义互斥变量mutex表示普通椅子情况（临界区），初始为1；定义理发师同步变量barbers表示等候顾客剪头发的理发师数，初始为0；定义顾客同步变量customers表示等待理发的顾客数（用于唤醒理发师），初始为0；定义wait表示等待的顾客数，Chair表示普通椅子数；
  ①理发师进程：
  semaphore mutex=1; // 互斥锁，共享内存互斥访问
  semaphore barbers=0; // 同步锁，无理发师等待
  semaphore customers=0; // 同步锁，无顾客等待
  int wait = 0; // 等待的顾客数
  int chairs = n; // 普通椅子数
  
  void Barber() {
  while(Ture) {
  	P(customers); // 等待顾客数，没有则睡觉（同步）
      P(mutex);
      wait--;
      V(barbers); // 释放理发师，被唤醒的理发师增加
      V(mutex);
      haircut(); // 处理，帮顾客剪头发，理发师在剪
  }}
  
  void Customer() {
  	P(mutex);
  	if(wait < chairs) {
  		wait++;
  		V(customers); // 等待顾客数增加，用于唤醒理发师
  		V(mutex);
  		P(barbers); // 申请理发师，没有则等待（同步）
  		get_haircut(); // 处理，顾客被理发
  	}
  	else {
  		V(mutex);
  	}
  }
  ```

- 读者-写者问题

  ```
  int count = 0; // 读者数
  semaphore count_mutex = 1; // 互斥锁
  semaphore data_mutex = 1; // 互斥锁
  
  void Reader() {
  	while(true) {
  		P(count_mutex);
  		count++;
  		if(count == 1) P(data_mutex);
  		V(count_mutex);
  		read();
  		P(count_mutex);
  		count--;
  		if(count == 0) V(data_mutex);
  		V(count_mutex);
  	}
  }
  
  void Writer() {
  	while(true) {
  		P(data_mutex);
  		writer();
  		V(data_mutex);
  	}
  }
  ```

- 哲学家就餐问题

- 管程

### 数据库



### 计算机网络



### 数据结构

- `二叉树`和`平衡二叉树(红黑树)`

  ```
  Graph Construction
  ```

- 

